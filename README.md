# minimazer
Сборка скриптом build.sh (на самом деле просто запускает make и скачивает библиотеку graphviz. Если библиотека уже есть, можно просто писать в консоли make, make clean тоже работает). Всё тестировалось на Ubuntu, работу на windows не гарантирую.

После сборки в корневой директории появляется исполняемый файл main. Запуск через консоль:  
./main -f \<file\> \<output\> --- прорисовывает граф по описанию автомата, которое содержится в файле file, сохраняет результат в output
./main -r \<file\> --- создаёт по описанию автомата минимальный автомат и сохраняет его в описанном ниже формате, прорисовывает   начальную и конечную картинки автомата, все три полученных файла сохраняются в папке io (рекомендуется класть входной файл туда же)  
./main -t --- запускает мои тесты. Входные файлы хранятся в папке tests в соответствующих поддиректориях, после запуска ./main -t в соответствующих папках появляются выходные файлы и картинки.  
  
 Формат описания автомата (формат входного и выходного файла):  
 В первой строке находятся два целых числа n, m --- количество вершин в автомате и количество символов автомата. Вершины и символы нумеруются с нуля!  
 Во второй строке одно целое число t --- количество терминальных вершин.  
 В следующей строке t целых чисел --- номера терминальных вершин в любом порядке.  
 Затем n блоков, нумерующихся с нуля. Блок с номером i начинается с целого числа k --- количество рёбер, выходящих из i   вершины. В следующих k строках находятся по два целых числа --- номер вершины, куда ведёт ребро, и номер символа, написанного на ребре.  
   
 Считается, что первый блок (вершина с номером ноль) соответствует стартовой вершине.  
   
 Разделители во входном файле не имеют значения, любой перенос строки можно заменить на пробел и наоборот.  
  
 Алгоритм для корректного результата создаёт специальную дьявольскую вершину (куда направляет ребро по символу из алфавита из любой вершины, включая дьявольскую, из которой нет перехода по данному символу). Однако, она нужна только для корректного нахождения классов эквивалентности, поэтому на последнем этапе она из графа исключается, так что изначально неполные, но минимальные, автоматы не меняют своего вида.   
